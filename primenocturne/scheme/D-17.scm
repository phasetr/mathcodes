"P.780"
"D.17 有限集合に対する諸計算"
(define (my-not P) (nand P))
(my-not #t)
(my-not #f)

(define (my-and P Q) (nand (nand P Q) (nand P Q)))
(define (my-or  P Q) (nand (nand P P) (nand Q Q)))
(my-and #t #t)
(my-and #t #f)
(my-and #f #t)
(my-and #f #f)
(my-or #t #t)
(my-or #t #f)
(my-or #f #t)
(my-or #f #f)

(define (xor P Q) (and (or P Q) (nand P Q)))
(xor #t #t)
(xor #t #f)
(xor #f #t)
(xor #f #f)

(define empty? null?)
(define element? member)
(define cardinal length)

(define (set+ A B)
  (cond ((empty? A) B)
        ((empty? B) A)
        ((element? (car A) B) (set+ (cdr A) B))
        (else (set+ (cdr A) (cons (car A) B)))))
(define (set* A B)
  (cond ((empty? A) '())
        ((empty? B) '())
        ((element? (car A) B) (cons (car A) (set* (cdr A) B)))
        (else (set* (cdr A) B))))
(define (set- A B)
  (cond ((empty? A) '())
        ((empty? B) A)
        ((element? (car A) B) (set- (cdr A) B))
        (else (cons (car A)   (set- (cdr A) B)))))

(define e20 (iota 2 20 2))
(define o20 (iota 1 20 2))
(define p20 (primes 20))

"P.782"
(set+ e20 o20)
(set* p20 o20)
(set- e20 p20)

(sort (set- (set+ o20 e20) p20))

(define (set-not A) (set- U A))
(define U (iota 9))
(set-not '(5))

(define (sub? A B)
  (cond ((empty? A) #t)
        ((element? (car A) B) (sub? (cdr A) B))
        (else #f)))
(define (seteq? A B)
  (and (sub? A B) (sub? B A)))

"P.783"
(define (set** A)
  (let ((fn (lambda (x) (cons (car A) x))))
    (cond ((empty? A) (list '()))
          (else (append (set** (cdr A))
                        (map fn (set** (cdr A))))))))
(set** (iota 3))
(cardinal (set** (iota 3)))
(cardinal (set** (iota 10)))

(define (combine A)
  (cond ((empty? A) '())
        ((element?  (car A) (cdr A)) (combine (cdr A)))
        (else (cons (car A)          (combine (cdr A))))))
(combine '((1 2) 3 (1 2) (2 3) 3 4))
(define (set-v A B)
  (combine (append A B)))
(define (set-xor A B)
  (set- (set+ A B) (set* A B)))
(set-xor '(a c e) '(a b c d e z))
